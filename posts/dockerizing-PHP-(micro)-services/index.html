<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Dockerizing PHP (Micro-) Services" /><meta name="author" content="Oliver" /><meta property="og:locale" content="en" /><meta name="description" content="When writing the backend for a web application, you might at one point come to the conclusion that you want to run dedicated (micro-)services for parts of the backendâ€™s functionality. For example you might have an API for CRUD operations in your online shop but handle billing through a separate service. It would be possible to host these services on different servers with different domains or use subdomains. But for me the best solution was to serve different APIs at different paths on the same server and dockerize the services. They are then served by the same webserver under the same IP and domain, which makes using cookies easier and does not require CORS configuration. Java or JavaScript were the languages of choice for me so far and here the web server is part of the application itself. Running the application will allow you to use a reverse proxy on your webserver to serve the application at the desired path. With Python the process is already a little more complicated, as you will have to run a separate WSGI or ASGI server that executes your code when it receives an HTTP request. But the way this server is executed makes it quite clear what happens because everything needs to be stated explicitly. 1 uvicorn --port 8080 --app-dir src main:app This lets uvicorn listen for HTTP requests on port 8080 and executes what is to be found inside app in the src/main.py file. PHP has a similar service, that allows executing PHP code in response to an HTTP request, named FPM (FastCGI Process Manager). But FPM is way less explicit in what it will do after you run it. To start the process it is enough to run php-fpm. This leaves a lot to your fantasy. What will be executed when? How do HTTP parameters and payload relate to the PHP arguments? Most of this is defined by the web server you are using. Nginx in my case. So I did what every reasonable person would do and copied code from a previous project without reading any documentation. 1 2 3 4 5 6 7 8 9 location ~ \.php$ { fastcgi_pass php_frontend; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; } } I replaced the regex to match my path, changed the php_frontend upstream to the name of my FPM container and rewrote the URL to cut out the part of the path that distinguished the different APIs (e.g. /api/crud/v1.0/products would be /products so the application doesnâ€™t have to be aware of how it is served on the internet). This gave me the following config: 1 2 3 4 5 6 7 8 9 10 location ~ api\/crud { rewrite \/api/crud\/[0-9]\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; } } Then I ran FPM in one container with the PHP files and nginx in another one. To nobodyâ€™s surprise but my own it didnâ€™t work. My simple assumption that everything would just work for some reason was shattered. Did the webserver require access to the files to read them and execute them through FPM? Or did FPM just need the right instructions to pick the right file to execute? I had to resort to desperate measures and actually read the docs. The server does indeed not need to have access to the files. The fastcgi_param SCRIPT_FILENAME param defined in the included fastcgi_params lets FPM know which file to pick. I used Symfony so I only ever want to execute one file; the index.php file in the projects root. But the SCRIPT_FILENAME sets it tos $document_root$fastcgi_script_name. The webserverâ€™s $document_root is not the same as the project root in the FPM container. This already rules out any of my setup would work. So with this in mind and knowing I always ever want to execute a single file, I set SCRIPT_FILENAME to the hardcoded value of fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; and mapped my Symfony projects root to /var/www as a docker volume. I held my breath and fired the request and it went throughâ€¦ With the wrong URI being requested from my application. Even though I rewrote the URI and the URI was logged correctly by Symfony, the 404 response returned by my app showed the original unaltered path (/api/crud/v1.0/products stayed /api/crud/v1.0/products instead of being just /products). So, some more docs ðŸ¥² The URI passed to FPM is defined by the REQUEST_URI parameter, again defined in the include. And this parameter is set to $request_uri. This is the requestâ€™s original URI before rewriting. A small change, setting it to $uri?$args instead and finally everything works. My final configuration is this: 1 2 3 4 5 6 7 8 location ~ \.php$ { rewrite \/api/crud\/[0-9]\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_param REQUEST_URI $uri?$args; fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; } } I use it for local development only and wouldnâ€™t recommend using it in production without some optimization. But you do you ðŸ‘Œ" /><meta property="og:description" content="When writing the backend for a web application, you might at one point come to the conclusion that you want to run dedicated (micro-)services for parts of the backendâ€™s functionality. For example you might have an API for CRUD operations in your online shop but handle billing through a separate service. It would be possible to host these services on different servers with different domains or use subdomains. But for me the best solution was to serve different APIs at different paths on the same server and dockerize the services. They are then served by the same webserver under the same IP and domain, which makes using cookies easier and does not require CORS configuration. Java or JavaScript were the languages of choice for me so far and here the web server is part of the application itself. Running the application will allow you to use a reverse proxy on your webserver to serve the application at the desired path. With Python the process is already a little more complicated, as you will have to run a separate WSGI or ASGI server that executes your code when it receives an HTTP request. But the way this server is executed makes it quite clear what happens because everything needs to be stated explicitly. 1 uvicorn --port 8080 --app-dir src main:app This lets uvicorn listen for HTTP requests on port 8080 and executes what is to be found inside app in the src/main.py file. PHP has a similar service, that allows executing PHP code in response to an HTTP request, named FPM (FastCGI Process Manager). But FPM is way less explicit in what it will do after you run it. To start the process it is enough to run php-fpm. This leaves a lot to your fantasy. What will be executed when? How do HTTP parameters and payload relate to the PHP arguments? Most of this is defined by the web server you are using. Nginx in my case. So I did what every reasonable person would do and copied code from a previous project without reading any documentation. 1 2 3 4 5 6 7 8 9 location ~ \.php$ { fastcgi_pass php_frontend; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; } } I replaced the regex to match my path, changed the php_frontend upstream to the name of my FPM container and rewrote the URL to cut out the part of the path that distinguished the different APIs (e.g. /api/crud/v1.0/products would be /products so the application doesnâ€™t have to be aware of how it is served on the internet). This gave me the following config: 1 2 3 4 5 6 7 8 9 10 location ~ api\/crud { rewrite \/api/crud\/[0-9]\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; } } Then I ran FPM in one container with the PHP files and nginx in another one. To nobodyâ€™s surprise but my own it didnâ€™t work. My simple assumption that everything would just work for some reason was shattered. Did the webserver require access to the files to read them and execute them through FPM? Or did FPM just need the right instructions to pick the right file to execute? I had to resort to desperate measures and actually read the docs. The server does indeed not need to have access to the files. The fastcgi_param SCRIPT_FILENAME param defined in the included fastcgi_params lets FPM know which file to pick. I used Symfony so I only ever want to execute one file; the index.php file in the projects root. But the SCRIPT_FILENAME sets it tos $document_root$fastcgi_script_name. The webserverâ€™s $document_root is not the same as the project root in the FPM container. This already rules out any of my setup would work. So with this in mind and knowing I always ever want to execute a single file, I set SCRIPT_FILENAME to the hardcoded value of fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; and mapped my Symfony projects root to /var/www as a docker volume. I held my breath and fired the request and it went throughâ€¦ With the wrong URI being requested from my application. Even though I rewrote the URI and the URI was logged correctly by Symfony, the 404 response returned by my app showed the original unaltered path (/api/crud/v1.0/products stayed /api/crud/v1.0/products instead of being just /products). So, some more docs ðŸ¥² The URI passed to FPM is defined by the REQUEST_URI parameter, again defined in the include. And this parameter is set to $request_uri. This is the requestâ€™s original URI before rewriting. A small change, setting it to $uri?$args instead and finally everything works. My final configuration is this: 1 2 3 4 5 6 7 8 location ~ \.php$ { rewrite \/api/crud\/[0-9]\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_param REQUEST_URI $uri?$args; fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; } } I use it for local development only and wouldnâ€™t recommend using it in production without some optimization. But you do you ðŸ‘Œ" /><link rel="canonical" href="https://oliver.diesdas.xyz/posts/dockerizing-PHP-(micro)-services/" /><meta property="og:url" content="https://oliver.diesdas.xyz/posts/dockerizing-PHP-(micro)-services/" /><meta property="og:site_name" content="DiesDas" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-23T18:12:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Dockerizing PHP (Micro-) Services" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Oliver" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Oliver"},"dateModified":"2022-04-23T18:12:00+02:00","datePublished":"2022-04-23T18:12:00+02:00","description":"When writing the backend for a web application, you might at one point come to the conclusion that you want to run dedicated (micro-)services for parts of the backendâ€™s functionality. For example you might have an API for CRUD operations in your online shop but handle billing through a separate service. It would be possible to host these services on different servers with different domains or use subdomains. But for me the best solution was to serve different APIs at different paths on the same server and dockerize the services. They are then served by the same webserver under the same IP and domain, which makes using cookies easier and does not require CORS configuration. Java or JavaScript were the languages of choice for me so far and here the web server is part of the application itself. Running the application will allow you to use a reverse proxy on your webserver to serve the application at the desired path. With Python the process is already a little more complicated, as you will have to run a separate WSGI or ASGI server that executes your code when it receives an HTTP request. But the way this server is executed makes it quite clear what happens because everything needs to be stated explicitly. 1 uvicorn --port 8080 --app-dir src main:app This lets uvicorn listen for HTTP requests on port 8080 and executes what is to be found inside app in the src/main.py file. PHP has a similar service, that allows executing PHP code in response to an HTTP request, named FPM (FastCGI Process Manager). But FPM is way less explicit in what it will do after you run it. To start the process it is enough to run php-fpm. This leaves a lot to your fantasy. What will be executed when? How do HTTP parameters and payload relate to the PHP arguments? Most of this is defined by the web server you are using. Nginx in my case. So I did what every reasonable person would do and copied code from a previous project without reading any documentation. 1 2 3 4 5 6 7 8 9 location ~ \\.php$ { fastcgi_pass php_frontend; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; } } I replaced the regex to match my path, changed the php_frontend upstream to the name of my FPM container and rewrote the URL to cut out the part of the path that distinguished the different APIs (e.g. /api/crud/v1.0/products would be /products so the application doesnâ€™t have to be aware of how it is served on the internet). This gave me the following config: 1 2 3 4 5 6 7 8 9 10 location ~ api\\/crud { rewrite \\/api/crud\\/[0-9]\\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; } } Then I ran FPM in one container with the PHP files and nginx in another one. To nobodyâ€™s surprise but my own it didnâ€™t work. My simple assumption that everything would just work for some reason was shattered. Did the webserver require access to the files to read them and execute them through FPM? Or did FPM just need the right instructions to pick the right file to execute? I had to resort to desperate measures and actually read the docs. The server does indeed not need to have access to the files. The fastcgi_param SCRIPT_FILENAME param defined in the included fastcgi_params lets FPM know which file to pick. I used Symfony so I only ever want to execute one file; the index.php file in the projects root. But the SCRIPT_FILENAME sets it tos $document_root$fastcgi_script_name. The webserverâ€™s $document_root is not the same as the project root in the FPM container. This already rules out any of my setup would work. So with this in mind and knowing I always ever want to execute a single file, I set SCRIPT_FILENAME to the hardcoded value of fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; and mapped my Symfony projects root to /var/www as a docker volume. I held my breath and fired the request and it went throughâ€¦ With the wrong URI being requested from my application. Even though I rewrote the URI and the URI was logged correctly by Symfony, the 404 response returned by my app showed the original unaltered path (/api/crud/v1.0/products stayed /api/crud/v1.0/products instead of being just /products). So, some more docs ðŸ¥² The URI passed to FPM is defined by the REQUEST_URI parameter, again defined in the include. And this parameter is set to $request_uri. This is the requestâ€™s original URI before rewriting. A small change, setting it to $uri?$args instead and finally everything works. My final configuration is this: 1 2 3 4 5 6 7 8 location ~ \\.php$ { rewrite \\/api/crud\\/[0-9]\\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_param REQUEST_URI $uri?$args; fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; } } I use it for local development only and wouldnâ€™t recommend using it in production without some optimization. But you do you ðŸ‘Œ","headline":"Dockerizing PHP (Micro-) Services","mainEntityOfPage":{"@type":"WebPage","@id":"https://oliver.diesdas.xyz/posts/dockerizing-PHP-(micro)-services/"},"url":"https://oliver.diesdas.xyz/posts/dockerizing-PHP-(micro)-services/"}</script><title>Dockerizing PHP (Micro-) Services | DiesDas</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="DiesDas"><meta name="application-name" content="DiesDas"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/avatar.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">DiesDas</a></div><div class="site-subtitle font-italic">A blog about stuff (related to software?)</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href=" javascript:location.href = 'mailto:' + ['oliver.flum','diesdas.xyz'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://github.com/oliverflum" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/oliver-flum-514b5b74/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Dockerizing PHP (Micro-) Services</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Dockerizing PHP (Micro-) Services</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/oliverflum">Oliver Flum</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1650730320" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-23 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="828 words"> <em>4 min</em> read</span></div></div></div><div class="post-content"><p>When writing the backend for a web application, you might at one point come to the conclusion that you want to run dedicated (micro-)services for parts of the backendâ€™s functionality. For example you might have an API for CRUD operations in your online shop but handle billing through a separate service. It would be possible to host these services on different servers with different domains or use subdomains. But for me the best solution was to serve different APIs at different paths on the same server and dockerize the services. They are then served by the same webserver under the same IP and domain, which makes using cookies easier and does not require CORS configuration.<br /> Java or JavaScript were the languages of choice for me so far and here the web server is part of the application itself. Running the application will allow you to use a reverse proxy on your webserver to serve the application at the desired path. With Python the process is already a little more complicated, as you will have to run a separate WSGI or ASGI server that executes your code when it receives an HTTP request. But the way this server is executed makes it quite clear what happens because everything needs to be stated explicitly.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>uvicorn --port 8080 --app-dir src main:app
</pre></table></code></div></div><p>This lets uvicorn listen for HTTP requests on port 8080 and executes what is to be found inside <code class="language-plaintext highlighter-rouge">app</code> in the <code class="language-plaintext highlighter-rouge">src/main.py</code> file. PHP has a similar service, that allows executing PHP code in response to an HTTP request, named FPM (FastCGI Process Manager). But FPM is way less explicit in what it will do after you run it. To start the process it is enough to run <code class="language-plaintext highlighter-rouge">php-fpm</code>. This leaves a lot to your fantasy. What will be executed when? How do HTTP parameters and payload relate to the PHP arguments? Most of this is defined by the web server you are using. Nginx in my case. So I did what every reasonable person would do and copied code from a previous project without reading any documentation.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>  location ~ \.php$ {
    fastcgi_pass php_frontend;
    include fastcgi_params;
    fastcgi_index index.php;
    fastcgi_buffers 16 16k;
    fastcgi_buffer_size 32k;
    fastcgi_read_timeout 600;
  }
}
</pre></table></code></div></div><p>I replaced the regex to match my path, changed the php_frontend upstream to the name of my FPM container and rewrote the URL to cut out the part of the path that distinguished the different APIs (e.g. <code class="language-plaintext highlighter-rouge">/api/crud/v1.0/products</code> would be <code class="language-plaintext highlighter-rouge">/products</code> so the application doesnâ€™t have to be aware of how it is served on the internet). This gave me the following config:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>  location ~ api\/crud {
    rewrite \/api/crud\/[0-9]\.[0-9](.*) $1 break;
    fastcgi_pass php_api;
    include fastcgi_params;
    fastcgi_index index.php;
    fastcgi_buffers 16 16k;
    fastcgi_buffer_size 32k;
    fastcgi_read_timeout 600;
  }
}
</pre></table></code></div></div><p>Then I ran FPM in one container with the PHP files and nginx in another one. To nobodyâ€™s surprise but my own it didnâ€™t work. My simple assumption that everything would just work for some reason was shattered.<br /> Did the webserver require access to the files to read them and execute them through FPM? Or did FPM just need the right instructions to pick the right file to execute? I had to resort to desperate measures and actually read the docs. The server does indeed not need to have access to the files. The <code class="language-plaintext highlighter-rouge">fastcgi_param SCRIPT_FILENAME</code> param defined in the included <code class="language-plaintext highlighter-rouge">fastcgi_params</code> lets FPM know which file to pick. I used Symfony so I only ever want to execute one file; the <code class="language-plaintext highlighter-rouge">index.php</code> file in the projects root. But the <code class="language-plaintext highlighter-rouge">SCRIPT_FILENAME</code> sets it tos <code class="language-plaintext highlighter-rouge">$document_root$fastcgi_script_name</code>. The webserverâ€™s <code class="language-plaintext highlighter-rouge">$document_root</code> is not the same as the project root in the FPM container. This already rules out any of my setup would work. So with this in mind and knowing I always ever want to execute a single file, I set <code class="language-plaintext highlighter-rouge">SCRIPT_FILENAME</code> to the hardcoded value of <code class="language-plaintext highlighter-rouge">fastcgi_param SCRIPT_FILENAME /var/www/public/index.php;</code> and mapped my Symfony projects root to <code class="language-plaintext highlighter-rouge">/var/www</code> as a docker volume. I held my breath and fired the request and it went throughâ€¦ With the wrong URI being requested from my application. Even though I rewrote the URI and the URI was logged correctly by Symfony, the 404 response returned by my app showed the original unaltered path (<code class="language-plaintext highlighter-rouge">/api/crud/v1.0/products</code> stayed <code class="language-plaintext highlighter-rouge">/api/crud/v1.0/products</code> instead of being just <code class="language-plaintext highlighter-rouge">/products</code>). So, some more docs ðŸ¥²<br /> The URI passed to FPM is defined by the <code class="language-plaintext highlighter-rouge">REQUEST_URI</code> parameter, again defined in the include. And this parameter is set to <code class="language-plaintext highlighter-rouge">$request_uri</code>. This is the requestâ€™s original URI before rewriting. A small change, setting it to <code class="language-plaintext highlighter-rouge">$uri?$args</code> instead and finally everything works. My final configuration is this:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  location ~ \.php$ {
    rewrite \/api/crud\/[0-9]\.[0-9](.*) $1 break;
    fastcgi_pass php_api;
    include fastcgi_params;
    fastcgi_param REQUEST_URI $uri?$args;
    fastcgi_param SCRIPT_FILENAME /var/www/public/index.php;
    }
  }
</pre></table></code></div></div><p>I use it for local development only and wouldnâ€™t recommend using it in production without some optimization. But you do you ðŸ‘Œ</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devops/'>DevOps</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/php/" class="post-tag no-text-decoration" >php</a> <a href="/tags/symfony/" class="post-tag no-text-decoration" >symfony</a> <a href="/tags/docker/" class="post-tag no-text-decoration" >docker</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://oliver.diesdas.xyz/posts/dockerizing-PHP-(micro)-services/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/performance-case-study/">React Performance Case Study</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/php/">php</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/symfony/">symfony</a> <a class="post-tag" href="/tags/typescript/">typescript</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/change/"><div class="card-body"> <em class="timeago small" data-ts="1661718000" > 2022-08-28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Always change a running system</h3><div class="text-muted small"><p> Jusquâ€™ici tout va bien In the 1995 movie â€˜La Haineâ€™ a narrator tells the story of a a man jumping of a building and, while falling, telling himself â€˜So far, everything went fineâ€™. After all itâ€™s t...</p></div></div></a></div><div class="card"> <a href="/posts/performance-case-study/"><div class="card-body"> <em class="timeago small" data-ts="1648320600" > 2022-03-26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>React Performance Case Study</h3><div class="text-muted small"><p> Performance Optimization Case-Study When implementing web applications using React, in many cases you will still have to rely on the native Web API to respond to events in your application. But whe...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/performance-case-study/" class="btn btn-outline-primary" prompt="Older"><p>React Performance Case Study</p></a> <a href="/posts/change/" class="btn btn-outline-primary" prompt="Newer"><p>Always change a running system</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> Â© 2022 <a href="https://github.com/oliverflum">Oliver Flum</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/php/">php</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/symfony/">symfony</a> <a class="post-tag" href="/tags/typescript/">typescript</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
