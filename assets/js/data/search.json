[ { "title": "Always change a running system", "url": "/posts/change/", "categories": "General", "tags": "", "date": "2022-08-28 22:20:00 +0200", "snippet": "Jusquâ€™ici tout va bienIn the 1995 movie â€˜La Haineâ€™ a narrator tells the story of a a man jumping of a building and, while falling, tellinghimself â€˜So far, everything went fineâ€™. After all itâ€™s the impact that will kill him and not the fall.In the movie this story serves as a parable for the French society failing to address its social issues withinimpoverished neighborhoods until the tensions caused by social injustices release in a violent clash.This way of addressing (or rather not addressing) obvious consequences of acting neglectful is a behavioral pattern,that occurs across cultures, classes and at any organizational scale. In the software industry this behavior is often accompanied by the utterance of the mantraâ€˜Never change a running systemâ€™While in the short term you might coast along just fine (the fall), sticking with that motto will probably cause a catastrophe or a slow and steady decline down the line (the impact).From a business perspective, you might have a unique idea that lets your company rise to the top by opening new markets.But sooner or later, other people will figure out the secret to your success und you will have to compete on a more and moresaturated market for diminishing revenues or the demand will tail off as the publicâ€™s attention shifts.Within the organization the â€˜never changeâ€™-approach, can cause issues with staffing and people management. The most qualified employeeswill sooner or later leave an organization that prevents them from growing. The people that stay will strengthen the organizations disposition to avoid change. Once outside circumstances force the organization to adapt, it will be full of people that try to avoid change and are not up to date with the current state of technology. New hires that are skilled with the increasingly esoteric tech stack will be harder to find and very senior hence expensive. Junior hiresâ€™ skills will deviate further and further from your requirements causing excessive onboarding costs.On a yet more granular scope, technical debt will build up over time and the cost of the changes required to adapt your system to an ever changing set of external dependencies will be way bigger than the sum of all the small incremental updates you could have done over the course of the years.The underlining issue is the assumption that the never changing system is part of a constant world. But the world will change withutter indifference towards the system, while people assume that what they perceived in their formative years is an irrefutable truth.You must change to keep up with a changing world." }, { "title": "Dockerizing PHP (Micro-) Services", "url": "/posts/dockerizing-PHP-(micro)-services/", "categories": "DevOps", "tags": "php, symfony, docker", "date": "2022-04-23 18:12:00 +0200", "snippet": "When writing the backend for a web application, you might at one point come to the conclusion that you want to run dedicated (micro-)services for parts of the backendâ€™s functionality. For example you might have an API for CRUD operations in your online shop but handle billing through a separateservice. It would be possible to host these services on different servers with different domains or use subdomains. But for me the best solution was to serve different APIs at different paths on the same server and dockerize the services. They are then served by the same webserver under the same IP and domain, which makes using cookies easierand does not require CORS configuration.Java or JavaScript were the languages of choice for me so far and here the web server is part of the application itself. Running the application will allow you to use a reverse proxy on your webserver to serve the application at the desired path. With Python the process is already a little more complicated, as you will have to run a separate WSGI or ASGI server that executes your code when it receives an HTTP request. But the way this server is executed makes it quite clear what happens because everything needs to be stated explicitly.uvicorn --port 8080 --app-dir src main:appThis lets uvicorn listen for HTTP requests on port 8080 and executes what is to be found inside app in the src/main.py file.PHP has a similar service, that allows executing PHP code in response to an HTTP request, named FPM (FastCGI Process Manager).But FPM is way less explicit in what it will do after you run it. To start the process it is enough to run php-fpm. This leavesa lot to your fantasy. What will be executed when? How do HTTP parameters and payload relate to the PHP arguments? Most of this is defined by the web server you are using. Nginx in my case. So I did what every reasonable person would do and copied code from a previous project without reading any documentation. location ~ \\.php$ { fastcgi_pass php_frontend; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; }}I replaced the regex to match my path, changed the php_frontend upstream to the name of my FPM container and rewrote the URL to cut out the part of the path that distinguished the different APIs (e.g. /api/crud/v1.0/products would be /products so the application doesnâ€™t have to be aware of how it is served on the internet). This gave me the following config: location ~ api\\/crud { rewrite \\/api/crud\\/[0-9]\\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_read_timeout 600; }}Then I ran FPM in one container with the PHP files and nginx in another one. To nobodyâ€™s surprise but my own it didnâ€™t work. My simple assumption that everything would just work for some reason was shattered.Did the webserver require access to the files to read them and execute them through FPM? Or did FPM just need the right instructions to pick the right file to execute? I had to resort to desperate measures and actually read the docs. The server does indeed not need to have access to the files. The fastcgi_param SCRIPT_FILENAME param defined in the included fastcgi_params lets FPM know which file to pick. I used Symfony so I only ever want to execute one file; the index.php file in the projects root. But the SCRIPT_FILENAME sets it tos$document_root$fastcgi_script_name. The webserverâ€™s $document_root is not the same as the project root in the FPM container.This already rules out any of my setup would work. So with this in mind and knowing I always ever want to execute a single file, I set SCRIPT_FILENAME to the hardcoded value of fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; and mapped my Symfony projects root to /var/www as a docker volume. I held my breath and fired the request and it went throughâ€¦ With the wrong URI being requested from my application. Even though I rewrote the URI and the URI was logged correctly by Symfony, the 404 response returned by my app showed the original unaltered path (/api/crud/v1.0/products stayed /api/crud/v1.0/products instead of being just /products). So, some more docs ðŸ¥²The URI passed to FPM is defined by the REQUEST_URI parameter, again defined in the include. And this parameter is set to $request_uri. This is the requestâ€™s original URI before rewriting. A small change, setting it to $uri?$args instead and finally everything works. My final configuration is this: location ~ \\.php$ { rewrite \\/api/crud\\/[0-9]\\.[0-9](.*) $1 break; fastcgi_pass php_api; include fastcgi_params; fastcgi_param REQUEST_URI $uri?$args; fastcgi_param SCRIPT_FILENAME /var/www/public/index.php; } }I use it for local development only and wouldnâ€™t recommend using it in production without some optimization. But you do you ðŸ‘Œ" }, { "title": "React Performance Case Study", "url": "/posts/performance-case-study/", "categories": "SoftwareDevelopment", "tags": "react, typescript", "date": "2022-03-26 19:50:00 +0100", "snippet": "Performance Optimization Case-StudyWhen implementing web applications using React, in many cases you will still have to rely on thenative Web API to respond to events in your application. But when combined with closures andReact hooks, event listeners create many pitfalls, that might impact performance or break an application altogether andthat are not obvious or easily understandable. I want to use a fairly basic component I implemented to illustrate some ofthese pitfalls and describe available solutions to avoid issues or alleviate performance degradation.The ComponentThe component I will use in this case study is a carousel/slider component that presents multiple options vertically lined up and allows the user to scroll through them if there are more options available than the slider can fit. To indicate that there are extra options available, two buttons show up on the left and right sidewhen the content overflows. They change color when the end of the scrollable area is reached.To accommodate users that canâ€™t scroll horizontally (e.g. when using a mouse with a scroll wheel), the buttonsscroll the content in the direction they are pointing to when clicked. To allow the color changing behavior, the component will require a scroll event listener that checks whether the scrollable area reached the end on either side and then updates the state to change the color. In addition, a resize listener on the window is required to make the buttons appear if the slideroptions overflow or disappear if the slider becomes big enough to display all options at the same time. The overall component is split into four sub-components. The â€˜carouselâ€™, which is a container for everything.The slider which holds the scrollable options and the indicator-buttons. The already mentioned indicator buttonsand an â€˜ItemChipâ€™ which takes care of the visual presentation of the options. Only the Slider and Indicator componentscontain logic related to event handling, so the others will not be considered much, but are available with therest of the code.Naive ImplementationA naive implementation of that component is displayed below. While it is straightforward and it is easy to understandwhat happens, the naive implementation comes with a number of problems. Most of these can be already demonstratedin the Slider component. To keep the article more readable, I will leave out the Scroll Indicator for now as well.Sliderimport * as React from &quot;react&quot;;import ScrollIndicator, {IndicatorDirection} from &quot;./ScrollIndicator&quot;;import QuickFilterChip from &quot;./ItemChip&quot;;import &#39;./Slider.scss&#39;type SliderProps = { items: {title: string} []}const Slider: React.FC&amp;lt;SliderProps&amp;gt; = (props:SliderProps) =&amp;gt; { const valuesRef = React.useRef&amp;lt;HTMLDivElement&amp;gt;(null); const containerRef = React.useRef&amp;lt;HTMLDivElement&amp;gt;(null); const [showIndicators, setShowIndicators] = React.useState((valuesRef.current as HTMLDivElement).scrollWidth &amp;gt; (valuesRef.current as HTMLDivElement).clientWidth); window.addEventListener(&#39;resize&#39;, () =&amp;gt; { const values = valuesRef.current as HTMLDivElement; const scrollable = values.scrollWidth &amp;gt; values.clientWidth; setShowIndicators(scrollable); }); return &amp;lt;div className=&quot;slider&quot;&amp;gt; {showIndicators &amp;amp;&amp;amp; &amp;lt;ScrollIndicator direction={IndicatorDirection.LEFT} containerRef={containerRef} valuesRef={valuesRef}/&amp;gt;} &amp;lt;div ref={containerRef} className=&quot;slider__value-container&quot;&amp;gt; &amp;lt;div ref={valuesRef} className=&quot;slider__values&quot;&amp;gt; {props.items.map(item =&amp;gt; &amp;lt;QuickFilterChip key={item.title} label={item.title}/&amp;gt;)} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; {showIndicators &amp;amp;&amp;amp; &amp;lt;ScrollIndicator direction={IndicatorDirection.RIGHT} containerRef={containerRef} valuesRef={valuesRef}/&amp;gt;} &amp;lt;/div&amp;gt;;};export default Slider;This is a straightforward and simple implementation of the described component. It has a state to keep track of whether or not to show the indicators which is initiated to the true/false depending on the size of the elements. It also uses references for the elementsin the DOM that we want to interact with. Unfortunately it doesnâ€™t work. When itâ€™s executed, it will cause an error message in the consoleand does not render.react-refresh-runtime.development.js:316 Uncaught TypeError: Cannot read properties of null (reading &#39;scrollWidth&#39;)This can be prevented by adding question marks after reading from the valuesRef, e.g.React.useState((valuesRef.current as HTMLDivElement).scrollWidth =&amp;gt; React.useState((valuesRef.current as HTMLDivElement)?.scrollWidthThis successfully masks the error and allows you to pass code review. The component now fails quietly and lived happily ever after.Fixing the IssuesTo truly address the underlying issue weâ€™ll have to look into the workings of react and understand when code is executed and which valuesit reads from its variables at execution time.1. Getting Refs RightThe first issue weâ€™ll address is the incorrect use of references. References are mutable objects that can be used to store stateful data.When passed to a react element in the ref key, the reference will always contain a reference to its current DOM node.But because the component is not yet rendered, this node does not exist and the reference value is null. Trying to read properties of thisnull value causes the initial error. Adding the question mark makes the reading evaluate to undefined. Therefor the component seems to work,but when the window is small enough for the slider to be scrollable, the indicators wonâ€™t show. Only after the component rendered the first time,everything would work.=&amp;gt; When using refs, be aware that they are only readable after the component is rendered.2. Using useEffectTo make sure the component already rendered when you read the references, you can use the useEffect hook. This hook is passed a function that is executed by react after the component was rendered. We wrap the check of whether the indicators should be shown in a function, so we donâ€™t have to replicatethe code for the initialization and end up with this:const Slider: React.FC&amp;lt;SliderProps&amp;gt; = (props:SliderProps) =&amp;gt; { const valuesRef = React.useRef&amp;lt;HTMLDivElement&amp;gt;(null); const containerRef = React.useRef&amp;lt;HTMLDivElement&amp;gt;(null); const [showIndicators, setShowIndicators] = React.useState(false); React.useEffect(() =&amp;gt; { const updateIndicators = () =&amp;gt; { const values = valuesRef.current as HTMLDivElement; const scrollable = values?.scrollWidth &amp;gt; values?.clientWidth; setShowIndicators(scrollable); } updateIndicators(); window.addEventListener(&#39;resize&#39;, updateIndicators); }) return &amp;lt;div className=&quot;slider&quot;&amp;gt; {showIndicators &amp;amp;&amp;amp; &amp;lt;ScrollIndicator direction={IndicatorDirection.LEFT} containerRef={containerRef} valuesRef={valuesRef}/&amp;gt;} &amp;lt;div ref={containerRef} className=&quot;slider__value-container&quot;&amp;gt; &amp;lt;div ref={valuesRef} className=&quot;slider__values&quot;&amp;gt; {props.items.map(item =&amp;gt; &amp;lt;QuickFilterChip key={item.title} label={item.title}/&amp;gt;)} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; {showIndicators &amp;amp;&amp;amp; &amp;lt;ScrollIndicator direction={IndicatorDirection.RIGHT} containerRef={containerRef} valuesRef={valuesRef}/&amp;gt;} &amp;lt;/div&amp;gt;;};No more exceptions ðŸ¥° Time to look into improving performance. As of now, this implementation has two major issues.Every time the component state changes, we unfortunately run the effect and create a new listener, even though it is independent ofthe state and really stays the same between renders. Even worse, every time the effect is run, we register a â€˜newâ€™ listenerand they start accumulating over time (To see this you can add a new state in the component that increments or changesin some way and log it from the listener).So letâ€™s address â€˜even worseâ€™ first before looking into â€˜unfortunatelyâ€™. It has an easy fix. We have to use useEffectâ€™s clean-up.When returning a function from useEffect, it is executed after the component unmounts or rerenders. So removing theevent listener in that function will get rid of most trouble:React.useEffect(() =&amp;gt; { const updateIndicators = () =&amp;gt; { const values = valuesRef.current as HTMLDivElement; const scrollable = values?.scrollWidth &amp;gt; values?.clientWidth; setShowIndicators(scrollable); } updateIndicators(); window.addEventListener(&#39;resize&#39;, updateIndicators); return () =&amp;gt; { window.removeEventListener(&#39;resize&#39;, updateIndicators) }})Now the listeners donâ€™t accumulate anymore. But wouldnâ€™t it be neat if we also avoided all the unnecessary instantiations oflisteners and calls to the browser API? How could you sleep at night if you didnâ€™t answer this question with yes?Fortunately useEffect allows conditional execution of effects based on an array of dependencies. If one of the dependencieschanges, the hook fires. Because references are mutable, they donâ€™t change between renders. Also the setShowIndicators functionstays usable after rerendering -&amp;gt; We only have to run the effect once and there for pass it an empty array of dependencies.React.useEffect(() =&amp;gt; {...}, [])There are other means of optimizing performance when using callbacks in react, e.g. the useCallback or useMemo hooks, but forI donâ€™t see any benefit in using them here, so as far as React goes weâ€™re done here. Time for some cake.=&amp;gt; To execute side effects or code that depends on the component already having rendered, use the useEffect hook=&amp;gt; Donâ€™t forget to clean up after your effects to prevent performance degradation over time=&amp;gt; Only run effects when necessary by providing a list of dependencies3. Filter out the noiseOf course there is more to the world than react and in an honest moment of self reflection, you might ask yourself, do I reallycare for all the events that window resizing causes? Do I need that many?If the answer is no, there is some further room to improve performance. Throttling and debouncing are techniques that allowyou to only call event listeners on a subset of all events that were fired. They are similar but not quite alike; same samebut different. We will use their lodash implementations. Debouncing lets you skip events until a more or less final state is reached. In our example, the listener is called oncethe window resizing stops. And because we only want to hide or show the scroll indicator buttons if the window gets bigger orsmaller ignoring all the events while resizing is fine. The user canâ€™t click those buttons anyway at that time.React.useEffect(() =&amp;gt; { const values = valuesRef.current as HTMLDivElement; const updateIndicators = () =&amp;gt; { const scrollable = values.scrollWidth &amp;gt; values.clientWidth; setShowIndicators(scrollable); } updateIndicators(); const debouncedCheckIndicators = debounce(checkShowIndicators, 100, { leading: false, trailing:true }); window.addEventListener(&#39;resize&#39;, debouncedCheckIndicators); return () =&amp;gt; { debouncedCheckIndicators.cancel(); window.removeEventListener(&#39;resize&#39;, debouncedCheckIndicators) }}, [])Throttling should be used when you do care about what happens between the final states, but only that much. It will allowyou to only react to events once every time a minimum time period has passed. This can be useful with scrolling, not only savingresources and optimizing performance but also making components feel less flakey. The slider component doesnâ€™t directly react to scrollevents and finally the stage is set for the scroll indicator.import * as React from &quot;react&quot;;import { throttle } from &quot;lodash&quot;;import classNames from &#39;classnames&#39;import &#39;./ScrollIndicator.scss&#39;;const SCROLL_BUFFER = 5;export enum IndicatorDirection { LEFT = &quot;left&quot;, RIGHT = &quot;right&quot;}; type ScrollDirectionType = `${IndicatorDirection}`; type IndicatorProps = { direction: ScrollDirectionType, containerRef: React.RefObject&amp;lt;HTMLDivElement&amp;gt; valuesRef: React.RefObject&amp;lt;HTMLDivElement&amp;gt;};const ScrollIndicator: React.FC&amp;lt;IndicatorProps&amp;gt; = (props:IndicatorProps) =&amp;gt; { const [active, setActive] = React.useState(false); React.useEffect(() =&amp;gt; { let values = props.valuesRef.current as HTMLDivElement; let container = props.containerRef.current as HTMLDivElement; const checkActive = () =&amp;gt; { let shouldBeActive; if (props.direction === IndicatorDirection.LEFT) { shouldBeActive = container.scrollLeft &amp;gt; SCROLL_BUFFER; } else { shouldBeActive = container.scrollLeft + SCROLL_BUFFER + container.offsetWidth &amp;lt; values.scrollWidth; } setActive(shouldBeActive); } checkActive(); const throttledCheckActive = throttle(checkActive, 100, {leading: false, trailing: true}); container.addEventListener(&#39;scroll&#39;, throttledCheckActive); return () =&amp;gt; { throttledCheckActive.cancel(); container.removeEventListener(&#39;scroll&#39;, throttledCheckActive); } }, []); const onClick = (e: React.MouseEvent) =&amp;gt; { let container = props.containerRef.current as HTMLDivElement; if (!active) { return } let scrollDist = container.clientWidth * 0.75; if (props.direction === IndicatorDirection.LEFT) { scrollDist = -1 * scrollDist; } let scrollPos = Math.max(container.scrollLeft + scrollDist, 0); container.scrollTo({left: scrollPos, behavior: &#39;smooth&#39;}); } return &amp;lt;div onClick={onClick} className={classNames(&quot;scroll-indicator&quot;, { &quot;active&quot;: active, &quot;left&quot;: props.direction === IndicatorDirection.LEFT, &quot;right&quot;: props.direction === IndicatorDirection.RIGHT })}&amp;gt; &amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 27.6 100&quot;&amp;gt; &amp;lt;polygon points=&quot;21.2,50 0,6.5 3.2,0 27.6,50 3.2,100 0,93.5 &quot;/&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;/div&amp;gt;};export default ScrollIndicator;The useEffect is a little stuffed here, because scrolling left and right donâ€™t share the exact same logic, but itillustrates the use of throttle nicely. Only react to events every 100ms and only after that delay has passed(falling flank). In both cases, donâ€™t forget to cancel the throttled/debounced function to prevent delayed listenerexecution if the component unmounts and maybe take a look at the lodash docs and this helpful articleby David Corbacho before using those functions. Also keep in mind that calling debounce or throttle is a quite expensivecall itself. If you have many dependencies in your listener you might lose more than you gain.The final component is available here.Feel free to (ab)use it." } ]
